##### wepack配置？babel配置？es6转es5工具有哪些?

##### webpack与grunt和gulp的区别
[前端工程的构建工具对比 Gulp vs Grunt](https://segmentfault.com/a/1190000002491282)

[gulp和webpack究竟有什么区别？](https://segmentfault.com/q/1010000008058766)

gulp的五个api:gulp.task,gulp.run,gulp.watch,gulp.src,gulp.dest

1. Gulp相比Grunt更简洁，而且遵循代码优于配置策略，维护Gulp更像是写代码。而且Gulp遵循CommonJS规范，因此跟写Node程序没有差别，没有产生中间文件。

2. Gulp相比Grunt更有设计感，核心设计基于Unix流的概念，通过管道连接，不需要写中间文件。

3. Gulp的每个插件只完成一个功能，这也是Unix的设计原则之一，各个功能通过流进行整合并完成复杂的任务。
   
4. 使用Grunt的I/O过程中会产生一些中间态的临时文件，一些任务生成临时文件，其它任务可能会基于临时文件再做处理并生成最终的构建后文件。
   而使用Gulp的优势就是利用流的方式进行文件的处理，通过管道将多个任务和操作连接起来，因此只有一次I/O的过程，流程更清晰，更纯粹。

**grunt**:许多常见的任务都有现成的Grunt插件，而且有众多第三方插件。grunt更像是写配置。

**gulp**:gulp强调的是前端开发的工作流程，我们可以通过配置一系列的task，定义task处理的事务（例如文件压缩合并、雪碧图、启动server、版本控制等），然后定义执行顺序，来让gulp执行这些task，从而构建项目的整个前端开发流程。

**webpack**:webpack是一个前端模块化方案，更侧重模块打包，我们可以把开发中的所有资源（图片、js文件、css，sass,coffeescript文件等）都看成模块，通过loader（加载器）和plugins（插件）对资源进行处理，打包成符合生产环境部署的前端资源。拆分依赖树成块并按需加载,让初始化加载时间更少,每一个静态资源应该是一个模块,能够集成第三方类库,适用于大型项目,能够定制模块打包的每一个部分.

###### 怎么加快webpack构建
[参考1](http://hpoenixf.com/%E5%8A%A0%E5%BF%ABwebpack%E6%9E%84%E5%BB%BA.html)
[参考2](https://www.cnblogs.com/imwtr/p/7801973.html)

1. 在开发环境不使用babel转码，仅在生产环境使用。本地开发的chrome的es6的兼容性足够好，不需要babel转码，经测试，这一操作可以减少25%的构建时间。
2. 在开发环境不使用post-css，关闭压缩css，可以提升10%的速度。
3. 在entry中仅引入当前开发的页面，这一举措可以提升一倍的构建速度，在其他步奏完成后，还需要12秒左右的构建速度，完成该步骤后，仅需五秒的构建时间。
4. 开发环境启用热更新替换,线上环境的编译，加个 --watch 参数就可以了
5. 启动HappyPack,会采用多进程去打包构建，但并不是支持所有的loader,首先引入，定义一下这个插件所开启的线程，推荐是四个，其实也可以直接使用默认的就行了
6. 代码压缩用ParallelUglifyPlugin代替自带的 UglifyJsPlugin插件,ParallelUglifyPlugin可以并行执行。

##### 利用webpack如何优化前端性能? 
1. 提取React、jQuery等库文件，提取公共代码。并且得到长时间的缓存。WebPack.optimize.CommonsChunkPlugin
2. 压缩代码
3. 用webpack时一般都会选择多入口文件吧，为的就是将自己的源码跟第三方库代码分离。首页需要的库先加载。

##### babel的原理，具体怎么做的？怎么区分<是小于号还是开始的符号。
[Babel是如何读懂JS代码的](https://zhuanlan.zhihu.com/p/27289600)

> 如果是开始符号<，肯定有结束符号>对应的，小于号<是双目运算符，左右两边应该是数值

> Babel的功能非常纯粹，以字符串的形式将源代码传给它，它就会返回一段新的代码字符串（以及sourcemap）。他既不会运行你的代码，也不会将多个代码打包到一起，它就是个编译器，输入语言是ES6+，编译目标语言是ES5。

1. 解析：将代码字符串解析成抽象语法树。 
可以验证语法的正确性，同时由字符串变为对象结构后更有利于精准地分析以及进行代码结构调整。

    1. 分词：将整个代码字符串分割成 **语法单元** 数组
    2. 语义分析：在分词结果的基础之上分析 语法单元之间的关系

2. 变换：对抽象语法树进行变换操作。 
遍历这个对象所描述的抽象语法树，遇到哪里需要做一下改变，就直接在对象上进行操作。

3. 再建：根据变换后的抽象语法树再生成代码字符串。 
递归遍历这颗语法树，然后生成相应的代码



