### HTTP协议类
- HTTP协议的主要特点
- HTTP报文的组成
- HTTP方法
- POST和GET的区别
- HTTP状态吗
- 什么是持久链接
- 什么是管线化

##### HTTP协议的主要特点
- 简单快速，灵活，无连接，无状态

##### HTTP报文的组成部分（要知道每一部分的组成）
> 请求报文
>> 请求行，请求头，空行，请求体

> 响应报文
>> 状态行，响应头，空行，响应体

##### HTTP方法
- GET, POST, PUT, DELETE, HEAD, TRACE

HRAD: 类似于get请求，只不过返回中没有具体的内容，用户获取报头


##### post 和 put的区别？
- put 幂等，每次相同的提交影响的结果相同,只是简单的更新资源
- post 非幂等，多次提交结果不同，post每一次提交创建一次
[理解POST和PUT的区别，顺便提下RESTful](https://www.cnblogs.com/ximenxiazi/p/5850273.html)
[HTTP中post和put的根本区别和优势](https://www.zhihu.com/question/48482736)

##### GET和POST的区别
- GET在浏览器回退/刷新时是无害的，而POST会再次提交请求（重要）
- GET请求会被浏览器主动缓存，而POST不会，除非手动设置（重要）
- GET请求参数会被完整保留在浏览器记录里，而POST中的参数不会被保留（重要）
- GET请求在url中传送的参数是有长度限制的，而POST没有限制（重要）
- GET参数通过URL传递，POST放在Request body中（重要）
- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。且POST参数不会被保留在浏览器历史或web服务器日志中。
- GET产生的URL地址可以被收藏，而POST不可以
- GET请求只能进行url编码，而POST支持多种编码方式
- 对参数的数据类型，GET只接受ASCII字符，而POST没有限制
- 多数浏览器对于POST采用两阶段发送数据的，先发送请求头，再发送请求体，即使参数再少再短，也会被分成两个步骤来发送（相对于GET），也就是第一步发送header数据，第二步再发送body部分。HTTP是应用层的协议，而在传输层有些情况TCP会出现两次连结的过程，HTTP协议本身不保存状态信息，一次请求一次响应。对于TCP而言，通信次数越多反而靠性越低，能在一次连结中传输完需要的消息是最可靠的，尽量使用GET请求来减少网络耗时。如果通信时间增加，这段时间客户端与服务器端一直保持连接状态，在服务器侧负载可能会增加，可靠性会下降。

#### GET请求传参长度的误区
*误区：我们经常说get请求参数的大小存在限制，而post请求的参数大小是无限制的*
> Http Get方法提交的数据大小长度并没有限制，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。

- 即使有长度限制，也是限制的是整个 URI 长度，而不仅仅是你的参数值数据长度。
- HTTP 协议从未规定 GET/POST 的请求长度限制是多少
- 不同的浏览器和WEB服务器，限制的最大长度不一样
- 要支持IE，则最大长度为2083byte，若只支持Chrome，则最大长度 8182byte

[关于 HTTP GET/POST 请求参数长度最大值的一个理解误区](https://blog.csdn.net/a460550542/article/details/72511343)

#### GET和POST请求缓存方面的区别？
- get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存，前提设置了缓存
- post不同，post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适合于请求缓存资源

##### HTTP状态码

> 重要的码：200,206,301,302,304,400,401,403,404,500,503

##### HTTP持久连接
> HTTP持久连接1.1版本才支持，知道持久连接和非持久连接

##### 管线化
 在使用持久连接的情况下，某个连接上的消息的传递类似于：请求1->响应1->请求2->响应2->请求3->响应3

 管线化下的消息传递类似于：请求1->请求2->请求3->响应1->响应2->响应3，原理即是把消息打包发送回来

**管线化的特点**：
1. 管线化机制通过持久链接完成，仅HTTP/1.1支持此技术（重要）
2. 只有GET和HEAD请求可以进行管线化，而POST则有所限制（重要）
3. 初次创建连接时不应启动管线机制，因为对方（服务器）不一定支持HTTP/1.1版本的协议。（重要）
4. 管线化不会影响响应到来的顺序，如上面的例子所示，响应返回的顺序并未改变
5. HTTP/1.1要求服务器端支持管线化，但并不要求服务器端也对响应进行进行管线化处理，只是要求管线化的请求不失败即可（了解）
6. 由于上面提到的服务器端问题，开启管线化很可能并不会带来大幅度的性能提升，而且很多服务器端和代理程序对管线化支持并不太好，因此现代浏览器如Chrome和Firefox默认并未开启管线化支持；


##### http断点续传？
1. Range,用于请求头中，指定第一个字节的位置和最后一个字节的位置，一般格式：`Range:(unit=first byte pos)-[last byte pos]`
2. Content-Range,用于响应头中，在发出带 Range 的请求后，服务器会在 Content-Range 头部返回当前接受的范围和文件总大小。
3. 返回的响应内容

        HTTP/1.1 200 Ok（不使用断点续传方式） 
        HTTP/1.1 206 Partial Content（使用断点续传方式）

**增强校验**
终端发起续传请求时，URL 对应的文件内容在服务器端已经发生变化，此时续传的数据肯定是错误的。如何解决这个问题了？显然此时需要有一个标识文件唯一性的方法。

`If-Range:Etag|HTTP-Date`If-Range 可以使用 Etag 或者 Last-Modified 返回的值。当没有 ETage 却有 Last-modified 时，可以把 Last-modified 作为 If-Range 字段的值。判断服务器目标内容是否发生了变化
 

**为什么优先用Etag?**

[参考](http://blog.csdn.net/liang19890820/article/details/53215087)

##### hybrid了解吗？与native通信这块了解吗

##### 若某一个页面有cookie，页面中有多个依赖的静态资源，页面加载时这些静态资源会默认都带上cookie，而静态资源并不需要cookie验证，造成了严重的浪费，降低了访问速度？
**优化**
- 静态资源分组，放在不同的域名下
- 不会带上不同不同域名的cookie

**问题**
- 移动端请求域名过多会降低请求速度，因为整套域名解析很耗时。
- 优化方案：`dns-prefetch`让浏览器空闲时提前解析dns域名。

##### 如果服务器端更新脚本，如何保证客户端不受缓存机制影响，实时更新脚本？

##### http状态码有哪些？
**概述**

- 1XX 信息性状态码  接收的请求正在处理
- 2XX 成功状态码    请求正常处理完毕
- 3XX 重定向状态码  需要进行附加操作以完成请求
- 4XX 客户端错误状态码 服务器无法处理请求
- 5XX 服务器错误状态码 服务器处理请求出错

**重要的状态码**
101,200,301,302,304,307，401,404,500

+ 101,协议升级，websocket升级和HTTP2升级可加进来,HTTP2的好处与HTTP1的比较   
+ 301,永久重定向。避免出现“此网页无法显示”之类的错误；对于网站的SEO是很重要的。
+ 302,临时重定向
+ 304，协商缓存，引进浏览器缓存知识，强制缓存，协商缓存...
+ 307，hsts跳转。原本的用法是用于让post请求的跳转去新的post请求，但也用于hsts跳转。
+ 400,请求无效
    - 前端提交数据的字段名称和字段类型与后台的实体没有保持一致
    - 前端提交到后台的数据应该是json字符串类型，但是前端没有将对象JSON.stringify转化成字符串。
+ 401，当前请求需要用户验证
+ 403，服务器已经得到请求，但是拒绝执行

[关于HTTP307状态码](https://zhangzifan.com/http-307-code.html)
[参考](http://hpoenixf.com/%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E4%B9%8Bhttp%E7%8A%B6%E6%80%81%E7%A0%81%E6%9C%89%E5%93%AA%E4%BA%9B.html#more)

##### HSTS
[从 HTTP 到 HTTPS 再到 HSTS](https://zhuanlan.zhihu.com/p/28874099)

使用：网站采用 HSTS 后，用户访问时无需手动在地址栏中输入 HTTPS，浏览器会自动采用 HTTPS 访问网站地址，从而保证用户始终访问到网站的加密链接，保护数据传输安全。

HSTS 主要是通过服务器发送响应头的方式来控制浏览器操作：

1. 首先在服务器响应头中添加 HSTS 响应头：
Strict-Transport-Security: max-age=expireTime [; includeSubDomains] [; preload] 
此响应头只有在 https 访问返回时才生效，其中[ ]中的参数表示可选；

2. 设置 max-age 参数，时间设置不宜过长，建议设置时间为 6 个月；

3. 当用户下次使用 HTTP 访问，客户端就会进行内部跳转，并且能够看到 307 Redirect Internel 的响应码；

4. 网站服务器变成了 HTTPS 访问源服务器。
开启 HSTS 后网站可以有效防范中间人的攻击，同时也会省去网站 301/302 跳转花费的时间，大大提升安全系数和用户体验。

##### 如何避免301跳转https(在response中header)？
开启hsts

##### HTTPS通信过程
1. 客户端向服务器发送协议版本号、客户端生成的**随机数**、以及客户端支持的加密算法
2. 服务器返回确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的**随机数**（证书其实就是一对公钥和私钥，只用于加密解密对话秘钥随机数）
3. 客户端确认数字证书有效，然后生成一个新的**随机数**，并使用数字证书中的公钥加密这个随机数发给服务端
4. 服务端使用私钥解密客户端发来的随机数
5. 服务器和客户端根据约定的加密方法，使用前面的三个随机数生成‘对话秘钥’用来加密接下来的整个过程

[参考](https://github.com/youngwind/blog/issues/108)

[想不通HTTPS如何校验证书合法性来看](http://xujinyang.github.io/2016/06/15/%E6%83%B3%E4%B8%8D%E9%80%9AHTTPS%E5%A6%82%E4%BD%95%E6%A0%A1%E9%AA%8C%E8%AF%81%E4%B9%A6%E5%90%88%E6%B3%95%E6%80%A7%E6%9D%A5%E7%9C%8B/)

##### HTTP有几种请求头？option请求头的作用?
[参考](https://www.cnblogs.com/cp168168/p/7923227.html)
[http请求详解](https://blog.csdn.net/qq_33020901/article/details/70146044)

OPTIONS请求方法的主要用途有两个：

1、获取服务器支持的HTTP请求方法；也是黑客经常使用的方法。

2、用来检查服务器的性能。例如：AJAX进行跨域请求时的预检，需要向另外一个域名的资源发送一个HTTP OPTIONS请求头，用以判断实际发送的请求是否安全。

##### Http报头Accept与Content-Type的区别
1.Accept属于请求头， Content-Type属于实体头。 
Http报头分为通用报头，请求报头，响应报头和实体报头。 
请求方的http报头结构：通用报头|请求报头|实体报头 
响应方的http报头结构：通用报头|响应报头|实体报头

2.Accept代表发送端（客户端）希望接受的数据类型。 
比如：Accept：text/xml; 
代表客户端希望接受的数据类型是xml类型

Content-Type代表发送端（客户端|服务器）发送的实体数据的数据类型。 
比如：Content-Type：text/html; 
代表发送端发送的数据格式是html。
[Http Header里的Content-Type](https://www.cnblogs.com/52fhy/p/5436673.html)

二者合起来， 
Accept:text/xml； 
Content-Type:text/html 
即代表希望接受的数据类型是xml格式，本次请求发送的数据的数据格式是html。

###### 302和303、307的区别
[HTTP状态码302、303和307的故事](https://www.cnblogs.com/cswuyg/p/3871976.html)


##### http和https的区别？
[参考](https://www.cnblogs.com/wqhwe/p/5407468.html)

##### http keep-alive详解
[HTTP keep-alive详解](https://blog.csdn.net/xiaoduanayu/article/details/78386508)



##### HTTP2.0
http和https的区别，相比于http,https是基于ssl加密的http协议
简要概括：http2.0是基于1999年发布的http1.0之后的首次更新。

- 提升访问速度（可以对于，请求资源所需时间更少，访问速度更快，相比http1.0）
- 允许多路复用：多路复用允许同时通过单一的HTTP/2连接发送多重请求-响应信息。改善了：在http1.1中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制（连接数量），超过限制会被阻塞。
- 二进制分帧：HTTP2.0会将所有的传输信息分割为更小的信息或者帧，并对他们进行二进制编码
- 首部压缩
- 服务器端推送
- 请求优先级

[HTTP 2.0 原理详细分析](https://blog.csdn.net/zhuyiquan/article/details/69257126?locationNum=4&fps=1#3-%E8%AF%B7%E6%B1%82%E4%BC%98%E5%85%88%E7%BA%A7)

**怎么启用HTTP2.0**
[HTTP2.0 介绍以及ngnix、tomcat下如何配置](https://blog.csdn.net/qq_16320025/article/details/79495469)

##### fetch发送2次请求的原因
fetch发送post请求的时候，总是发送2次，第一次状态码是204，第二次才成功.
原因很简单，因为你用fetch的post请求的时候，导致fetch 第一次发送了一个Options请求，询问服务器是否支持修改的请求头，如果服务器支持，则在第二次中发送真正的请求。

[参考](https://segmentfault.com/q/1010000008693779)

###### 表单上传的集中方式？
[WEB前端上传图片的几种方法](https://www.cnblogs.com/gongyue/p/7686359.html)
[前端上传文件的方法总结](https://www.cnblogs.com/soraly/p/8441589.html)



