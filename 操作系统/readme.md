##### 操作系统常见题？
[链接](http://blog.csdn.net/zhou753099943/article/details/51771220)

##### 线程和进程的区别？
1. 进程是资源的分配资源的一个独立单元，而线程是CPU调度的基本单元
2. 同一个进程中可以包括多个线程，并且线程共享整个进程的资源（寄存器、堆栈、上下文），一个进程至少包括一个线程。
3. 进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进程中的其他线程的结束
4. 线程是轻量级，它的创建和销毁所需要的时间比进程小很多，所有操作系统中的执行功能都是创建线程去完成的
5. 线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源
6. 线程有自己的私有属性TCB，线程id，寄存器、硬件上下文，而进程也有自己的私有属性进程控制块PCB，这些私有属性是不被共享的，用来标示一个进程或一个线程的标志

##### 死锁？死锁产生的原因？死锁的必要条件？怎么处理死锁？
[参考](http://blog.csdn.net/cout_sev/article/details/24836673)

死锁： 相互等待资源而产生的一种僵持状态，如果没有外力的干预将一直持续这个状态           <br>
原因： 系统资源不足、相互竞争资源、请求资源顺序不当                                <br>
必要条件： 互斥、不可抢占、循环等待、请求与保持                                   <br>
处理： 因为互斥是不可改变的，所以只能破坏其他三个条件中的一个来解除死锁，方法：剥夺资源、杀死其中一个线程     <br>

##### 进程的几种状态？
1. run（运行状态）：正在运行的进程或在等待队列中对待的进程，等待的进程只要以得到cpu就可以运行
2. Sleep（可中断休眠状态）：相当于阻塞或在等待的状态
3. D（不可中断休眠状态）：在磁盘上的进程
4. T（停止状态）：这种状态无法直观的看见，因为是进程停止后就释放了资源，所以不会留在linux中
5. Z（僵尸状态）：子进程先于父进程结束，但父进程没有调用wait或waitpid来回收子进程的资源，所以子进程就成了僵尸进程，如果父进程结束后任然没有回收子进程的资源，那么1号进程将回收

##### IPC通信方式？（进程间通信）
[参考](http://blog.csdn.net/tangchao1011/article/details/39475183)

1. 管道（匿名管道（pipe亲缘关系的进程通信）、命名管道（nameed pipe））。 管道可用于具有亲缘关系进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。
2. 消息队列：是基于消息的、用无亲缘关系的进程间通信
3. 信号量：主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段。
4. 共享内存：是进程间通信速度最快的，它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新,这种方式需要依靠某种同步操作,所以用经常是集合信号量或互斥锁来实现同步

##### 操作系统内存的管理方式？
[分页和分段内存管理](https://blog.csdn.net/bupt_tinyfisher/article/details/8939689)

分块：把主存分为一大块一大块的，当所需的程序片段不在主存时就分配一块主存空间，把程序片段load入主存，就算所需的程序片段只有几个字节也只能把这一块分配给它。这样会造成很大的浪费，平均浪费了50%的内存空间，但是易于管理。

分页：把主存分为一页一页的，每一页的空间要比一块一块的空间小很多，这种方法的空间利用率要比块式管理高很多
**优点**：没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）

分段：把主存分为一段一段的，每一段的空间又要比一页一页的空间小很多，这种方法在空间利用率上又比页式管理高得多，但是也有另外一个缺点。一个程序片段可能会被分为几十段，这样很多时间就会被浪费在计算每一段的物理地址上。
**优点**：没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）


段页式管理：结合了段式管理和页式管理的优点。把主存先分成若干段，每个段又分成若干页。段页式管理每取一护具，要访问3次内存。


##### 什么是虚拟内存？
[参考](http://blog.csdn.net/qq_30137611/article/details/66478426)

是将进程部分装入内存中，从而能实现一个很大的程序能在一个比它小的内存中运行，它的主要实现是靠程序的换进换出来实现的，因为内存中0~3G是用户使用，3~4G才是内存使用，通过映射来实现来进行逻辑地址到物理地址的映射

##### 虚拟地址、逻辑地址、线性地址、物理地址的区别？
分段机制把一个逻辑地址转换为线性地址；接着，分页机制把一个线性地址转换为物理地址。
1. 虚拟地址：虚拟内存映射出来的地址
2. 逻辑地址：程序的段加偏移量形成的，C/C++程序中取地址求出来的地址就是逻辑地址
3. 线性地址：是逻辑地址到物理地址的中间层，只有启动分页机制的时候才有线性地址，如果没有分页机制，那么线性地址就是物理地址
4. 物理地址：是内存中实实在在存在的硬件地址，
逻辑地址（启动分段）--》线性地址（启动分页）--》物理地址


##### 什么是正向代理？什么是反向代理？
[参考](https://www.cnblogs.com/Anker/p/6056540.html)

正向代理 是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。

正向代理的用途：
1. 访问原来无法访问的资源，如google
2. 可以做缓存，加速访问资源
3. 对客户端访问授权，上网进行认证
4. 代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息

##### 线程的那些资源共享，那些资源不共享
线程共享的环境包括：进程代码段、进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。

线程不共享的资源：线程ID,寄存器组的值，线程的栈，错误返回码，线程的信号屏蔽码，线程的优先级
